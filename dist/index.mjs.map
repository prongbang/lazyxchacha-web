{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import * as x25519 from '@stablelib/x25519';\nimport {NONCE_LENGTH, XChaCha20Poly1305} from \"@stablelib/xchacha20poly1305\";\nimport {randomBytes} from \"@stablelib/random\";\nimport * as hex from \"@stablelib/hex\";\n\nexport function generateKeyPair(): { pk: string, sk: string } {\n    const kp = x25519.generateKeyPair();\n    return {\n        pk: hex.encode(kp.publicKey),\n        sk: hex.encode(kp.secretKey),\n    };\n}\n\nexport function sharedKey(sk: string, pk: string): string {\n    const publicKey = hex.decode(pk);\n    const secretKey = hex.decode(sk);\n    const key = x25519.sharedKey(secretKey, publicKey);\n    return hex.encode(key);\n}\n\nfunction combined(arr1: Uint8Array, arr2: Uint8Array) {\n    return new Uint8Array([...arr1, ...arr2]);\n}\n\nfunction concatenation(nonceBytes: Uint8Array, cipherText: Uint8Array, macBytes: Uint8Array): Uint8Array {\n    let n = cipherText.length;\n    n += nonceBytes.length;\n    n += macBytes.length;\n\n    const result = new Uint8Array(n);\n    let i = 0;\n    result.set(nonceBytes, i);\n\n    i += nonceBytes.length;\n    result.set(cipherText, i);\n\n    i += cipherText.length;\n    result.set(macBytes, i);\n\n    return result;\n}\n\nfunction encode(data: string): Uint8Array {\n    return new TextEncoder().encode(data);\n}\n\nfunction decode(data: Uint8Array): string {\n    return new TextDecoder().decode(data);\n}\n\nexport function encrypt(data: string, key: string): string {\n    const keyBytes = hex.decode(key);\n    const xChaCha = new XChaCha20Poly1305(keyBytes);\n    const nonce = randomBytes(NONCE_LENGTH);\n    const plaintext = encode(data);\n\n    const ciphertext = xChaCha.seal(nonce, plaintext);\n\n    // Convert nonce and ciphertext and mac to hexadecimal strings\n    return hex.encode(combined(nonce, ciphertext));\n}\n\nexport function decrypt(data: string, key: string): string {\n    const keyBytes = hex.decode(key);\n    const xChaCha = new XChaCha20Poly1305(keyBytes);\n\n    const cipherBytes = hex.decode(data);\n    const nonce = cipherBytes.slice(0, NONCE_LENGTH);\n    const ciphertext = cipherBytes.slice(NONCE_LENGTH);\n\n    const plaintext = xChaCha.open(nonce, ciphertext);\n\n    if (plaintext == null) return \"\";\n\n    return decode(plaintext)\n}"],"mappings":";AAAA,YAAY,YAAY;AACxB,SAAQ,cAAc,yBAAwB;AAC9C,SAAQ,mBAAkB;AAC1B,YAAY,SAAS;AAEd,SAASA,mBAA8C;AAC1D,QAAM,KAAY,uBAAgB;AAClC,SAAO;AAAA,IACH,IAAQ,WAAO,GAAG,SAAS;AAAA,IAC3B,IAAQ,WAAO,GAAG,SAAS;AAAA,EAC/B;AACJ;AAEO,SAASC,WAAU,IAAY,IAAoB;AACtD,QAAM,YAAgB,WAAO,EAAE;AAC/B,QAAM,YAAgB,WAAO,EAAE;AAC/B,QAAM,MAAa,iBAAU,WAAW,SAAS;AACjD,SAAW,WAAO,GAAG;AACzB;AAEA,SAAS,SAAS,MAAkB,MAAkB;AAClD,SAAO,IAAI,WAAW,CAAC,GAAG,MAAM,GAAG,IAAI,CAAC;AAC5C;AAoBA,SAASC,QAAO,MAA0B;AACtC,SAAO,IAAI,YAAY,EAAE,OAAO,IAAI;AACxC;AAEA,SAASC,QAAO,MAA0B;AACtC,SAAO,IAAI,YAAY,EAAE,OAAO,IAAI;AACxC;AAEO,SAAS,QAAQ,MAAc,KAAqB;AACvD,QAAM,WAAe,WAAO,GAAG;AAC/B,QAAM,UAAU,IAAI,kBAAkB,QAAQ;AAC9C,QAAM,QAAQ,YAAY,YAAY;AACtC,QAAM,YAAYD,QAAO,IAAI;AAE7B,QAAM,aAAa,QAAQ,KAAK,OAAO,SAAS;AAGhD,SAAW,WAAO,SAAS,OAAO,UAAU,CAAC;AACjD;AAEO,SAAS,QAAQ,MAAc,KAAqB;AACvD,QAAM,WAAe,WAAO,GAAG;AAC/B,QAAM,UAAU,IAAI,kBAAkB,QAAQ;AAE9C,QAAM,cAAkB,WAAO,IAAI;AACnC,QAAM,QAAQ,YAAY,MAAM,GAAG,YAAY;AAC/C,QAAM,aAAa,YAAY,MAAM,YAAY;AAEjD,QAAM,YAAY,QAAQ,KAAK,OAAO,UAAU;AAEhD,MAAI,aAAa;AAAM,WAAO;AAE9B,SAAOC,QAAO,SAAS;AAC3B;","names":["generateKeyPair","sharedKey","encode","decode"]}